
#----------------------------------#
## Database Configuration
#----------------------------------#
#Set the database connection URL
spring.datasource.url = jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
#Set the database username and password using the environment variables
spring.datasource.username = ${DB_USERNAME}
spring.datasource.password= ${DB_PASSWORD}
#Specify the PostgreSQL JDBC driver class name
spring.datasource.driver-class-name = org.postgresql.Driver
#Configure Hibernate to automatically update the database schema based on the entity definitions, which is useful during development to keep the schema in sync with the code changes.
spring.jpa.hibernate.ddl-auto = update
#Enable SQL query logging
spring.jpa.show-sql = true 
#Make those SQL queries formatted for better readability in the logs
spring.jpa.properties.hibernate.format_sql = true 
#Fixes PostgreSQL LOB handling issues by enabling non-contextual creation of LOBs, which can help prevent errors related to large object handling in Hibernate when working with PostgreSQL. Only needed for PostgreSQL.
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
#Open-in-view keeps the Hibernate session (JPA EntityManager) open for the entire HTTP request lifecycle, not just during the service layer transaction. This mainly allows lazy loading in controller or in view layer, but it can cause hidden performance issues, N+1 query problems, hard to debug database access and resource leaks if not used carefully. OSIV is generally not recommended for production applications, and it is often better to fetch all necessary data in the service layer and close the session before returning the response. Setting this to false ensures that the session is closed after the service layer, which can help prevent these issues during development.
spring.jpa.open-in-view=false

#Prepared Statements cache for PostgreSQL

#After exceuting the same SQL query 3 times, HikariCP will start using prepared statements for that query, which can improve performance by allowing the database to cache the execution plan for that query. Setting this to 3 means that after the same query is executed 3 times, it will be prepared and cached by the database.
spring.datasource.hikari.data-source-properties.prepareThreshold = 3
#Number of prepared statements to cache per DB connection.
spring.datasource.hikari.data-source-properties.prepStmtCacheSize = 256
#Size of memory allowed per connection for caching prepared statements.
spring.datasource.hikari.data-source-properties.preparedStatementCacheSizeMiB = 5

#----------------------------------#
## Connection Pool
#----------------------------------#
#Configure HikariCP connection pool settings for optimal performance and resource management.

#Set the maximum number of connections in the pool to 5, which is suitable for development environments to prevent resource exhaustion while allowing concurrent database access. (Default was 10)
spring.datasource.hikari.maximum-pool-size = 5

#How long the app waits in milliseconds to get a connection from the pool before failing. Setting this to 20000 (20 seconds) allows for a reasonable wait time in production environments where connections may be slower to acquire, while still ensuring that the application fails gracefully if the database is not responsive. (Default was 30000)
spring.datasource.hikari.connection-timeout =  20000

#Minimum number of idle connections that HikariCP tries to maintain in the pool. Setting this to 2 ensures that there are always a couple of connections ready for use, which can improve performance while still conserving resources in a development environment. (default was same as maximum-pool-size)
spring.datasource.hikari.minimum-idle = 3

#Maximum time in milliseconds that a connection can be idle in the pool before it is closed. Setting this to 300000 (5 minutes) allows for longer idle times during development, which can be helpful when connections are not used frequently, while still ensuring that resources are eventually freed. (default was 600000)
spring.datasource.hikari.idle-timeout = 300000

#Maximum lifetime of a connection in the pool in milliseconds. Setting this to 1200000 (20 minutes) ensures that connections are not kept open indefinitely, which can help prevent issues with stale connections and resource leaks during development. (default was 1800000). After this time a connection will be closed and a new one is created to repalce it.
#Should be less than the database's connection timeout to avoid unexpected disconnections. If PostgreSQL times out connections after 1 hour, set max-lifetime to 55 minutes to beat the database timeout and ensure connections are refreshed before they are closed by the database.
spring.datasource.hikari.max-lifetime = 1200000

#Leak detection - Logs a warning if a connection is borrowed from the pool but not returned within the specified time.
spring.datasource.hikari.leak-detection-threshold=60000


#----------------------------------#
## Logging Configuration
#----------------------------------#

#Set the logging level for Spring Framework to WARN to reduce log verbosity during development, while still allowing important warnings and errors to be logged. Other options are-
#TRACE: Logs everything, including detailed debugging information. This is the most verbose level and is typically used for troubleshooting specific issues.
#DEBUG: Logs detailed information useful for debugging, but less verbose than TRACE.
#INFO: Logs general informational messages about the application's normal operation. Shows startup info
#ERROR: Logs only error messages, which indicate serious issues that need attention.
#OFF: Disables all logging.
logging.level.org.springframework = WARN

#Set the logging level for the application's own packages to DEBUG to enable detailed logging of application-specific events, which can be helpful for development and debugging purposes. This allows developers to see more granular information about the application's behavior without being overwhelmed by Spring's internal logs.
#It is possible to set different logging levels for different packages or classes-
#logging.level.com.userauthenticationmicroservice.controller = INFO
#logging.level.com.userauthenticationmicroservice.service = ERROR
logging.level.com.userauthenticationmicroservice = DEBUG

#Authentication and authorization related logging
logging.level.org.springframework.security = DEBUG
# logging.level.org.springframework.boot.autoconfigure=DEBUG

#HTTP requests logging
logging.level.org.springframework.web = DEBUG

logging.level.org.hibernate.tool.schema=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.level.org.springframework.jdbc.datasource=DEBUG
logging.level.com.zaxxer.hikari=DEBUG

#Hibernate SQL logging - Logs the SQL statements generated by Hibernate. Setting this to DEBUG can be very verbose, so it's often set to INFO or OFF in production.
logging.level.root = INFO
logging.level.org.hibernate.SQL = OFF
logging.level.org.hibernate = ERROR


# ------------------#
## OTHER CONFIG
#-------------------#

#Actuator endpoints configuration - Expose only health,info and prometheus endpoints for monitoring and management purposes,while keeping other endpoints secure and hidden in production environments. This allows for essential monitoring without exposing sensitive information or management capabilities.
management.endpoints.web.exposure.include=health,info,prometheus
management.endpoint.health.show-details=never

#Server tuning - Increase the maximum number of threads that the embedded Tomcat server can use to handle incoming HTTP requests. Setting this to 200 allows the server to handle more concurrent requests, which can be beneficial in production environments with higher traffic, while still being a reasonable limit to prevent resource exhaustion.
server.tomcat.threads.max=200

#Graceful shutdown configuration - Configure the server to perform a graceful shutdown, allowing it to complete ongoing requests and release resources properly when the application is stopped. Setting the lifecycle timeout per shutdown phase to 30 seconds ensures that the server has enough time to finish processing requests and clean up resources before it is forcefully terminated, which can help prevent data loss and ensure a smoother shutdown process in production environments.
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s